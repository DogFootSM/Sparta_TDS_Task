using System;using System.Collections;using System.Collections.Generic;using System.Linq;using TMPro;using Unity.VisualScripting;using UnityEngine;using UnityEngine.Serialization;public class MonsterController : MonoBehaviour{    [SerializeField] private List<SpriteRenderer> _spriteRenderers;    public List<GameObject> _nextTargets = new List<GameObject>();    public bool CanJumping;    private Vector2 _targetPos;    private bool isJumping;    private float _moveSpeed = 2f;    private int _sortIndex = 1;    private int _curIndex;    private GameObject _switchMonster;    private MonsterPool _monsterPool;    private Coroutine _jumpCo;    private Coroutine _moveCo;    public MonsterController _monster;    private LayerMask _mask;    private Vector2 _rayPos;    private Ray2D _ray;    private RaycastHit2D _hit;    private void OnEnable()    {         CanJumping = true;        MonsterMove();    }    private void Update()    {        _rayPos = new Vector2(transform.position.x - 0.4f, transform.position.y + 0.3f);        _ray = new Ray2D(_rayPos, -Vector2.right);        Debug.DrawRay(_ray.origin, _ray.direction * 0.4f, Color.red);        if (!isJumping)        {            _hit = Physics2D.Raycast(_ray.origin, _ray.direction, _rayPos.x * 0.4f, _mask);            if (_hit.collider != null && !_hit.collider.gameObject.Equals(gameObject))            {                if (_hit.collider.TryGetComponent<MonsterController>(out _monster))                {                    _monster.CanJumping = false;                }            }        }    }    /// <summary>      /// 각 라인에 따라 레이어 지정      /// </summary>      /// <param name="layerIndex"></param>    public void SetSortingLayer(int layerIndex)    {        for (int i = 0; i < _spriteRenderers.Count; i++)        {            _spriteRenderers[i].sortingLayerName = layerIndex switch            {                0 => "CLine",                1 => "BLine",                2 => "ALine",                _ => "Default"            };        }    }    /// <summary>      /// 반납할 위치를 가지고 있는 몬스터 풀 받아옴      /// </summary>      /// <param name="monsterPool">스포너가 가지고 있는 몬스터 풀</param>      public void GetMonsterPool(MonsterPool monsterPool)    {        _monsterPool = monsterPool;    }    /// <summary>      /// 몬스터가 이동할 위치 설정      /// </summary>      public void GetTargets(List<GameObject> targetPos, LayerMask mask)    {        _nextTargets = targetPos;        _mask = 1 << mask;        gameObject.layer = mask;    }    /// <summary>      /// 몬스터 풀이 Null인지 확인      /// </summary>      /// <returns></returns>    public bool CheckMonsterPool() => _monsterPool == null;    /// <summary>      /// 몬스터 이동      /// </summary>      private void MonsterMove()    {        _moveCo = StartCoroutine(MonsterMoveRoutine());    }    /// <summary>      /// 몬스터 이동 코루틴      /// </summary>      /// <returns></returns>    private IEnumerator MonsterMoveRoutine()    {        while (true)        {            if (_monster != null)            {                _targetPos = new Vector2(_monster.transform.position.x + 0.4f, _monster.transform.position.y);                                if (Vector2.Distance(transform.position, _targetPos) < 0.001f)                {                    isJumping = true;                    yield return new WaitForEndOfFrame();                     _jumpCo = StartCoroutine(MonsterJumpRoutine());                }            }            else            {                _targetPos = new Vector2(-0.7f, transform.position.y);            }            transform.position = Vector2.MoveTowards(transform.position, _targetPos, _moveSpeed * Time.deltaTime);                        yield return null;        }    }    /// <summary>    /// 몬스터 점프 코루틴    /// </summary>    /// <returns></returns>    private IEnumerator MonsterJumpRoutine()    {        Vector2 curPos = transform.position;        Vector2 head;        float jumpHeight = 0.6f;        float duration = 0.5f;        float elapsedTime = 0f;        int jumpIndex = _nextTargets.IndexOf(_monster.gameObject);        _monster.CanJumping = true;        _monster = null;        if (_nextTargets.Contains(gameObject))        {            _nextTargets.Remove(gameObject);        }                for (int i = jumpIndex; i >= 0; i--)        {            head = new Vector2(_nextTargets[i].transform.position.x, _nextTargets[i].transform.position.y + 0.8f);            jumpHeight = 0.6f;            duration = 0.5f;            elapsedTime = 0f;            while (elapsedTime < duration)            {                elapsedTime += Time.deltaTime;                float time = elapsedTime / duration;                float height = Mathf.Sin(time * Mathf.PI) * jumpHeight;                transform.position = Vector3.Lerp(curPos, head, time) + new Vector3(0, height, 0);                yield return null;            }                    transform.position = head;            curPos = transform.position;        }                duration = 0.2f;        elapsedTime = 0f;        Vector3 startPos = transform.position;        Vector3 landPos = _nextTargets[0].transform.position;                while (elapsedTime < duration)        {            elapsedTime += Time.deltaTime;            float time = elapsedTime / duration;            transform.position = Vector3.Lerp(startPos, landPos, time);            yield return null;        }                transform.position = landPos;                if (!_nextTargets.Contains(gameObject))        {            _nextTargets.Insert(0, gameObject);        }                isJumping = false;    }    }